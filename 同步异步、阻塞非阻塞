http://www.jianshu.com/p/aed6067eeac9

Linux 5种IO模式 http://www.jianshu.com/p/486b0965c296

IO有两步：
第一阶段：等待数据准备 (Waiting for the data to be ready)。
第二阶段：将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)。

同步vs异步：主动等待，轮询等都是同步；消息通知是异步。
阻塞vs非阻塞：在等待过程中做其他的事情就是非阻塞，反之为同步。

多路复用IO http://xuding.blog.51cto.com/4890434/1739649
这个的叫法就多了，有些是同步非阻塞，有些是异步阻塞。
异步是因为用户线程注册事件处理器之后可以继续执行做其他的工作（异步），而Reactor线程负责调用内核的select函数检查socket状态，这个线程是同步的。
阻塞是因为，系统调用select读取是否有数据是阻塞。非阻塞是因为读取后的recvfrom方法不会阻塞，因为select之后必然存在。【不过IO第二阶段，
处理异步非阻塞，其他都是从内核到工作线程也是阻塞】
所以，如果对于reactor线程是同步非阻塞（IO层面），对于用户线程可以执行多个IO操作是异步阻塞。

CPU层次
在CPU层次，或者说操作系统进行IO和任务调度的层次，现代操作系统通常使用异步非阻塞方式进行IO（有少部分IO可能会使用同步非阻塞轮询），
即发出IO请求之后，并不等待IO操作完成，而是继续执行下面的指令（非阻塞），IO操作和CPU指令互不干扰（异步），最后通过中断的方式来通知IO操作完成结果。

线程层次
在线程层次，或者说操作系统调度单元的层次，操作系统为了减轻程序员的思考负担，将底层的异步非阻塞的IO方式进行封装，把相关系统调用（如read，write等）以同步的方式展现出来。
然而，同步阻塞的IO会使线程挂起，同步非阻塞的IO会消耗CPU资源在轮询上。为了解决这一问题，就有3种思路：多线程（同步阻塞）；
IO多路复用（select，poll，epoll）（同步非阻塞，严格地来讲，是把阻塞点改变了位置）；
直接暴露出异步的IO接口，如kernel-aio和IOCP（异步非阻塞）。

程序员感知层次
在Linux中，上面提到的第2种思路用得比较广泛，也是比较理想的解决方案。然而，直接使用select之类的接口，依然比较复杂，所以各种库和框架百花齐放，都试图对IO多路复用进行封装。
此时，库和框架提供的API又可以选择是以同步的方式还是异步的方式来展现。如python的asyncio库中，就通过协程，提供了同步阻塞式的API；如node.js中，就通过回调函数，提供了异步非阻塞式的API。
总结因此，我们在讨论同步、异步、阻塞、非阻塞时，必须先明确是在哪个层次进行讨论。
比如node.js，我们可以说她在程序员感知层次提供了异步非阻塞的API，也可以说在Linux下，她在线程层次以同步非阻塞的epoll来实现。
